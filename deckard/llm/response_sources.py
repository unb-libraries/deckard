import json
from langchain.chains import LLMChain
from logging import Logger

from deckard.core import json_dumper
from deckard.llm import fail_response
from deckard.core import extract_first_json_block

class ResponseSourceExtractor:
    """Processes response metadata to identify the contextual sources of a generated response.

    Args:
        chain (LLMChain): The LLM chain to infer against.
        logger (Logger): The logger
    """
    def __init__(self, chain: LLMChain, logger: Logger) -> None:
        self.chain = chain
        self.logger = logger

    def get_sources(self, query, response, chunks_used, top_n=4) -> tuple:
        """ Determines the sources of a generated response.

        This is really fragile as it depends on the response metadata being in a specific format. This should eventually
        be replaced with more static-oriented arguments.

        Args:
            query (str): The query
            response (str): The response
            chunks_used (list(dict)): the chunks used to assemble to context.

        Returns:
            tuple (str, bool, bool): The response/summarization was run/at least one of the queries was answered.
        """
        sources_used = []

        for chunk in chunks_used:
            if chunk['metadata']['source_type'] == 'webpage' and chunk['metadata']['source'] is not None and chunk['metadata']['source'] != '':
                print (chunk['metadata']['source'])
                sources_used.append( {
                    "chunk": chunk['chunk'],
                    "source": chunk['metadata']['source']
                    }
                )
                if len(sources_used) >= top_n:
                    break
        self.logger.info("Determining sources of response")
        chain_response = self.chain.invoke(
            {
                "llm_response": response,
                "retrieved_chunks": json_dumper(sources_used)
            }
        )

        self.response = chain_response
        try:
            json_response = extract_first_json_block(self.response, "Sources", self.logger)
            if json_response is None:
                reason = "Error parsing sources: no JSON found in extracted text"
                self.logger.error(reason)
                return False, reason, []
            if 'source_urls' in json_response:
                return json_response['source_urls'], "Success", json_response
            else:
                reason = "Error parsing sources: 'source_urls' not found in eval"
                self.logger.error(reason)
                return False, reason, []
        except Exception as e:
            reason = f"Error parsing sources: {e}"
            self.logger.error(reason)
            return False, reason, []

def get_sources_prompt() -> str:
    """Returns the prompt that instructs the LLM to identify the sources of a generated response.

    Returns:
        str: The prompt.
    """
    return """<|start_header_id|>system<|end_header_id|> 
You are a helpful AI agent that assists with retrieval-augmented generation (RAG) workflows. Your task is to analyze retrieved context chunks and determine which source URLs contributed to generating the given response. 

- Only include URLs from chunks that were **directly used** in forming the response.
- Err on the side of caution: if no retrieved chunks were used, return an empty list.
- Respond strictly in JSON format.<|eot_id|>

<|start_header_id|>user<|end_header_id|> 
Here is an response generated by an LLM along with the retrieved context chunks. Identify which chunks contributed to the response and return their source URLs.

#### Response:
```
{llm_response}
```

#### Retrieved Chunks:
```json
{retrieved_chunks}  // Each chunk includes metadata with a "source_url" field.
```

#### Instructions:
1. Compare the retrieved chunks with the response.
2. Determine which chunks contain **key facts, phrases, or direct references** used in the response.
3. Only include URLs from chunks that were **clearly used** to generate the response.
4. If no chunks contributed, return an empty list.
5. Respond **only** in JSON format.

## Output:
```json
{{
  "source_urls": ["URL1", "URL2", ...]  // Only include URLs of relevant chunks
}}
```

Respond **only** with the JSON object in the specified format. Do not include any additional text.
<|eot_id|><|start_header_id|>assistant<|end_header_id|>
"""
